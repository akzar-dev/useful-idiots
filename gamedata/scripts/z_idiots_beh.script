local WP    = world_property
local U     = z_idiots_utils
local C     = z_idiots_companions
local TABLE = require "illish.table"


local __custom_data = axr_beh.init_custom_data
local __set_target  = axr_beh.action_beh.set_desired_target
local __beh_move    = axr_beh.action_beh.beh_move
local __beh_wait    = axr_beh.action_beh.beh_wait
local __beh_cover   = axr_beh.action_beh.beh_cover


-- utils: formations --

function U.getBunchFormation(npc, st, pathfinder)
  local followers = U.getFollowers()

  local formation = U.getFormation(npc, {
    spacing    = math.max(2, 4.4 - 0.2 * #followers),
    columns    = math.max(2, U.round(math.sqrt(#followers))),
    distance   = st.desired_distance,
    pathfinder = pathfinder,
    noise      = 0.6
  })

  return formation and U.isValidLVID(npc, formation.vid)
    and formation.vid
    or  U.INVALID_LVID
end


function U.getLineFormation(npc, st, pathfinder)
  local followers = U.getFollowers()

  local formation = U.getFormation(npc, {
    spacing    = math.max(1.8, 3.8 - 0.2 * #followers),
    distance   = st.desired_distance,
    pathfinder = pathfinder,
    noise      = {0, 0.4},
  })

  return formation and U.isValidLVID(npc, formation.vid)
    and formation.vid
    or  U.INVALID_LVID
end


function U.getSpreadFormation(npc, st, pathfinder)
  local followers = U.getFollowers()

  local formation = U.getFormation(npc, {
    spacing    = math.max(2, 7 - 0.5 * #followers),
    distance   = st.desired_distance,
    pathfinder = pathfinder,
    columns    = #followers,
    noise      = {0.4, 0},
  })

  return formation and U.isValidLVID(npc, formation.vid)
    and formation.vid
    or  U.INVALID_LVID
end


function U.getCoverFormation(npc, st, pathfinder)
  local followers = U.getFollowers()

  local formation = U.getFormation(npc, {
    spacing    = math.max(3.2, 9.2 - 0.6 * #followers),
    distance   = st.desired_distance,
    pathfinder = pathfinder,
    columns    = #followers,
  })

  if not formation then
    return U.INVALID_LVID
  end

  local vid = U.findCover(npc, {
    enemyPos  = U.vectorOffset(db.actor:position(), formation.avgDir:invert(), 32),
    position  = formation.rawPos,
    radius    = 2,
  })

  return U.isValidLVID(npc, vid)
    and vid
    or  formation.vid
end


function U.getFormation(npc, ops)
  local index = U.indexOfFollower(npc)

  if not index then
    return
  end

  index = index - 1

  ops = TABLE.merge({
    pathfinder = U.bestEnclosedUnclaimedLVID,
    position   = db.actor:position(),
    distance   = 4,
    columns    = 1,
    spacing    = 1,
    noise      = 0,
  }, ops)

  local spacing = type(ops.spacing) == "table"
    and ops.spacing
    or  {ops.spacing, ops.spacing}

  local noise = type(ops.noise) == "table"
    and ops.noise
    or  {ops.noise, ops.noise}

  local followers = U.getFollowers()
  local avgPos    = U.getAvgPosition(followers)
  local avgDir    = vdir(ops.position, avgPos)
  local crossDir  = vector_rotate_y(avgDir, 90)
  local columns   = math.min(ops.columns, #followers)

  local offset = ops.distance + spacing[1] * math.floor(index / columns)
        offset = offset + U.randomRange(noise[1], 1)

  local crossOffset = spacing[2] * math.ceil(index % columns / 2)
        crossOffset = crossOffset * (index % 2 == 1 and -1 or 1)
        crossOffset = crossOffset + U.randomRange(noise[2], 1)

  if columns % 2 == 0 then
    crossOffset = crossOffset + spacing[2] / 2
  end

  local rawPos = U.vectorOffset(ops.position, avgDir, offset)
        rawPos = U.vectorOffset(rawPos, crossDir, crossOffset)

  return {
    vid    = ops.pathfinder(npc, rawPos),
    rawPos = rawPos,
    avgPos = avgPos,
    avgDir = avgDir,
  }
end


-- utils: relax --

function U.getNearbyCampfires(pos, radius)
  local fires = {}

  for id, binders in pairs(bind_campfire.campfires_all) do
    local dist = pos:distance_to(binders.object:position())

    if dist <= radius then
      fires[#fires + 1] = {
        id       = id,
        distance = dist,
        object   = binders.object,
        campfire = binders.campfire,
      }
    end
  end

  table.sort(fires, function(a, b)
    return a.distance < b.distance
  end)

  return fires
end


function U.findCampfireRelaxSpot(npc, pos, dist)
  dist = dist or 32
  local campfires = U.getNearbyCampfires(pos, dist)

  for _, campfire in ipairs(campfires) do
    local distance  = 1.8
    local increment = 72
    local angle     = 0

    while angle < 360 do
      local rads    = math.rad(angle)
      local placer  = vec(math.cos(rads), 0, math.sin(rads)):mul(distance)
      local firePos = campfire.object:position()
      local spotPos = vec(firePos):add(placer)
      local dir     = vdir(spotPos, firePos)
      local vid     = lvid(spotPos)

      if U.isUnoccupiedLVID(npc, vid) then
        return {
          campfire = campfire,
          firePos  = firePos,
          spotPos  = spotPos,
          vid      = vid,
          dir      = dir,
        }
      end

      angle = angle + increment
    end
  end
end


function U.findRandomRelaxSpot(npc, pos, dist)
  dist = dist or 16
  local enemyPos = U.vectorOffset(pos, U.randomRotate(), 32)

  local vid = U.findCover(npc, {
    enemyPos = enemyPos,
    radius   = dist,
    position = pos,
    minSpace = 3.2,
  })

  local dir = U.isValidLVID(npc, vid)
    and vdir(enemyPos, lvpos(vid))
    or  vdir(enemyPos, pos)

  return {
    enemyPos = enemyPos,
    vid      = vid,
    dir      = dir,
  }
end


-- utils: animation utils --

ANIMATION_CHOICES = {
  guard = {
    guard                           = {6, 0},
    guard_na                        = {4, 0},
    guard_chasovoy                  = {2, 30000},
    binocular                       = {2, 30000},
    ward                            = {1, 60000},
    animpoint_stay_ohrana           = {1, 60000},
    smoking_stand                   = {3, 60000},
    wait                            = {2, 120000},
    wait_na                         = {2, 120000},
    fold_arms                       = {1, 120000},
  },
  hide = {
    hide                            = {6, 0},
    hide_na                         = {4, 0},
    sit_ass_weapon                  = {1, 120000},
  },
  sit_ass = {
    animpoint_sit_ass               = {4, 0},
    animpoint_sit_ass_use_pda       = {2, 0},
    animpoint_sit_ass_smoking_sit   = {2, 0},
    animpoint_sit_ass_drink_vodka   = {2, 30000},
    animpoint_sit_ass_eat_bread     = {1, 30000},
    animpoint_sit_ass_eat_kolbasa   = {1, 30000},
    animpoint_sit_ass_drink_energy  = {1, 30000},
    animpoint_sit_ass_sleep         = {2, 120000},
  },
  sit_knee = {
    animpoint_sit_ass               = {4, 0},
    animpoint_sit_knee_drink_vodka  = {2, 30000},
    animpoint_sit_knee_eat_bread    = {1, 30000},
    animpoint_sit_knee_eat_kolbasa  = {1, 30000},
    animpoint_sit_knee_drink_energy = {1, 30000},
    animpoint_sit_knee_sleep        = {2, 120000},
  },
}


function U.chooseAnimation(state, st)
  local anims   = ANIMATION_CHOICES[state]
  local choices = {}

  if not anims then
    return state
  end

  for anim, ops in pairs(anims) do
    local chances   = ops[1] or 1
    local onlyAfter = ops[2] or 0

    if not (st and st.timeInState) or st.timeInState + onlyAfter <= time_global() then
      for i = 1, chances do
        choices[#choices + 1] = anim
      end
    end
  end

  return choices[table.random(choices)]
end


function U.getBehMoveState(npc, st)
  local dt   = st.desired_target
  local anim = st.moveState

  if dt.reached then
    anim = st.wait_animation
    st.moveState = nil
  end

  if not anim then
    local dist = npc:position():distance_to(dt.position)

    local walkDist = tonumber(
      xr_logic.pick_section_from_condlist(db.actor, npc, st.walk_dist)
      or 4
    )
    local jogDist = tonumber(
      xr_logic.pick_section_from_condlist(db.actor, npc, st.jog_dist)
      or 8
    )

    if dist <= walkDist then
      anim = st.walk_animation
    elseif dist <= jogDist then
      anim = st.jog_animation
    else
      anim = st.run_animation
    end
  end

  if anim ~= st.lastState then
    st.lastState   = anim
    st.timeInState = nil
    st.animFn      = nil
  end

  if not st.timeInState then
    st.timeInState = time_global()
  end

  if not st.animFn then
    st.animFn = U.throttle(U.chooseAnimation, 15000, 45000)
  end

  return st.animFn(anim, st)
end


function U.getBehLookState(npc, st)
  local dt = st.desired_target

  if dt.look_object then
    return {look_object = dt.look_object}
  end

  if dt.look_position then
    return {look_position = dt.look_position}
  end

  if dt.look_dir then
    return {look_dir = dt.look_dir}
  end

  return nil
end


-- utils: patrol waypoints --

function U.getWaypoint(npc, index)
  if type(npc) == "number" then
    npc = U.getCompanion(npc)
  end

  if (npc and index) then
    return se_load_var(npc:id(), npc:name(), "pathpoint" ..index)
  end
end


function U.getAllWaypoints(npc)
  if type(npc) == "number" then
    npc = U.getCompanion(npc)
    if not npc then
      return
    end
  end

  local waypoints = {}
  local index = 1
  local waypoint

  repeat
    waypoint = U.getWaypoint(npc, index)
    if waypoint then
      waypoints[#waypoints + 1] = waypoint
      index = index + 1
    end
  until
    waypoint == nil

  return waypoints
end


function U.addWaypoint(npc, pos)
  if type(npc) == "number" then
    npc = U.getCompanion(npc)
    if not (npc and pos) then
      return
    end
  end

  local x, y, z = pos.x, pos.y, pos.z
  local index   = #U.getAllWaypoints(npc) + 1
  local delay   = 8000

  local waypoint = string.format("%s,patrol | pos:%s,%s,%s", delay, x, y, z)
  se_save_var(npc:id(), npc:name(), "pathpoint" ..index, waypoint)

  return index
end


function U.clearWaypoints(npc)
  if type(npc) == "number" then
    npc = U.getCompanion(npc)
  end

  if not npc then
    return
  end

  printf("TESTING %s, %s, %s", C.getState(npc, "movement", "patrol"), C.getActiveState(npc, "movement"), C.getActiveState(nil, "movement"))

  if C.getState(npc, "movement", "patrol") then
    C.setState(npc, "movement", C.getActiveState(nil, "movement"), true)
  end

  printf("TESTING %s, %s, %s", C.getState(npc, "movement", "patrol"), C.getActiveState(npc, "movement"), C.getActiveState(nil, "movement"))
  -- for _, action in ipairs({"follow", "wait", "relax"}) do
    -- if C.GLOBAL_STATE[action] then
      -- C.setState(npc, "movement", action, true)
      -- break
    -- end
  -- end

  for index in ipairs(U.getAllWaypoints(npc)) do
    se_save_var(npc:id(), npc:name(), "pathpoint" ..index, nil)
  end
end


U.SELECTED_IDS = {}


function U.selectCompanion(npc)
  if U.SELECTED_IDS[npc:id()] then
    U.SELECTED_IDS[npc:id()] = nil
    return false
  end

  U.SELECTED_IDS[npc:id()] = true
  return true
end


function U.deselectCompanions()
  if #table.keys(U.SELECTED_IDS) == 0 then
    return false
  end

  U.SELECTED_IDS = {}
  return true
end


local evaluateSurroundings = U.throttle(U.evaluateSurroundings, 25)


local throttleActorPosition = U.throttle(function()
  return db.actor:position()
end, 100)


-- custom targets --

function U.setTargetLookAround(npc, st)
  local vid, pos, dir, reached =
    st.savedTarget.level_vertex_id,
    st.savedTarget.position,
    st.savedTarget.direction,
    st.savedTarget.reached

  if st.movePoint then
    vid = nil
  end

  if not vid then
    if st.movePoint then
      vid = st.movePoint
    else
      vid = npc:level_vertex_id()
    end

    st.movePoint = nil
  end

  pos     = lvpos(vid)
  dir     = vdir(pos, db.actor:position())
  reached = vid == npc:level_vertex_id()

  U.setDestination(npc, vid)

  st.desired_target = {
    look_dir        = reached and dir or nil,
    reached         = reached,
    level_vertex_id = vid,
    position        = pos,
    direction       = dir,
  }

  return true
end


function U.setTargetCoverSpot(npc, st)
  local vid, pos, dir, reached, expires =
    st.savedTarget.level_vertex_id,
    st.savedTarget.position,
    st.savedTarget.direction,
    st.savedTarget.reached,
    st.savedTarget.expires

  local movePoint, keepType = st.movePoint, st.keepType

  if expires and expires < time_global() then
    vid = nil
  end

  if movePoint then
    vid = nil
  end

  if not vid then
    st.movePoint = nil
    expires      = nil

    local distance = movePoint and 0
      or keepType == "near" and 2
      or keepType == "far" and 8
      or 4

    vid = U.findCover(npc, {
      position = movePoint and lvpos(movePoint),
      distance = distance,
      radius   = 8,
    })

    if not U.isValidLVID(npc, vid) then
      vid     = npc:level_vertex_id()
      expires = 1000 + time_global()
    end
  end

  pos     = lvpos(vid)
  dir     = vdir(pos, db.actor:position())
  reached = vid == npc:level_vertex_id()

  U.setDestination(npc, vid)

  st.desired_target = {
    look_dir        = reached and dir or nil,
    reached         = reached,
    expires         = expires,
    level_vertex_id = vid,
    position        = pos,
    direction       = dir,
  }

  return true
end


function U.setTargetFollowActor(npc, st)
  local actorPos     = throttleActorPosition()
  local formation    = C.getActiveState(npc, "formation")
  local surroundings = evaluateSurroundings(actorPos)
  local followCount  = #U.getFollowers()

  local vid, pos, dir, reached =
    st.savedTarget.level_vertex_id,
    st.savedTarget.position,
    st.savedTarget.direction,
    st.savedTarget.reached

  local lastVid, expires, savedActorPos, lastFormation, lastFollowCount =
    st.savedTarget.level_vertex_id,
    st.savedTarget.expires,
    st.savedTarget.actorPos,
    st.savedTarget.formation,
    st.savedTarget.followCount

  local keepDist, lastKeepType, lastTarget, movePoint, keepType, target =
    st.desired_distance,
    st.lastKeepType,
    st.lastTarget,
    st.movePoint,
    st.keepType,
    st.target

  if
    pos and savedActorPos
    and pos:distance_to(actorPos) > pos:distance_to(savedActorPos)
    and actorPos:distance_to(savedActorPos) > 1
  then
    vid = nil
  end

  if formation ~= lastFormation or keepType ~= lastKeepType then
    vid = nil
  end

  if followCount ~= lastFollowCount then
    vid = nil
  end

  if expires and expires < time_global() then
    vid = nil
  end

  if movePoint then
    vid = nil
  end

  if not vid then
    savedActorPos = actorPos
    st.movePoint = nil
    expires      = nil

    local pathfinder = keepType == "near" and surroundings.type == "cramped"
      and U.defaultEnclosedUnclaimedLVID
      or  U.bestEnclosedUnclaimedLVID

    if movePoint then
      vid = movePoint

    elseif surroundings.type == "cramped" and keepType ~= "near" then
      vid     = lastVid
      expires = 1000 + time_global()

    elseif formation == "line" then
      vid = U.getLineFormation(npc, st, pathfinder)

    elseif formation == "bunch" then
      vid = U.getBunchFormation(npc, st, pathfinder)

    elseif formation == "spread" then
      vid = U.getSpreadFormation(npc, st, pathfinder)

    elseif formation == "covered" then
      vid = U.getCoverFormation(npc, st, pathfinder)
    end

    if not U.isValidLVID(npc, vid) then
      vid     = npc:level_vertex_id()
      expires = 1000 + time_global()
    end
  end

  pos     = lvpos(vid)
  dir     = vdir(pos, actorPos)
  reached = vid == npc:level_vertex_id()

  U.setDestination(npc, vid)

  st.desired_target = {
    look_dir        = reached and dir or nil,
    actorPos        = savedActorPos,
    followCount     = followCount,
    formation       = formation,
    expires         = expires,
    reached         = reached,
    direction       = dir,
    position        = pos,
    level_vertex_id = vid,
  }

  return true
end


function U.setTargetRelaxSpot(npc, st)
  local vid, dir, pos, reached, expires =
    st.savedTarget.level_vertex_id,
    st.savedTarget.direction,
    st.savedTarget.position,
    st.savedTarget.reached,
    st.savedTarget.expires

  local movePoint, keepType = st.movePoint, st.keepType

  if expires and expires < time_global() then
    vid = nil
  end

  if st.movePoint then
    vid = nil
  end

  if not vid then
    st.movePoint = nil
    expires      = nil

    local startPos = movePoint
      and lvpos(movePoint)
      or  db.actor:position()

    local spot = U.findCampfireRelaxSpot(npc, startPos)

    if not spot then
      local dist = keepType == "near" and 8
        or keepType == "far" and 24
        or 16

        spot = U.findRandomRelaxSpot(npc, startPos, dist)
    end

    if U.isValidLVID(npc, spot.vid) then
      vid = spot.vid
      dir = spot.dir
    else
      vid     = npc:level_vertex_id()
      expires = 1000 + time_global()
      dir     = nil
    end
  end

  pos = lvpos(vid)
  reached = vid == npc:level_vertex_id()

  U.setDestination(npc, vid)

  st.desired_target = {
    look_dir        = reached and dir or nil,
    reached         = reached,
    expires         = expires,
    level_vertex_id = vid,
    direction       = dir,
    position        = pos,
  }

  return true
end


CUSTOM_TARGETS = {
  cover_spot   = U.setTargetCoverSpot,
  cover_actor  = U.setTargetFollowActor,
  follow_actor = U.setTargetFollowActor,
  look_around  = U.setTargetLookAround,
  relax_spot   = U.setTargetRelaxSpot,
}


function axr_beh.init_custom_data(npc, ini, section, st, scheme)
  __custom_data(npc, ini, section, st, scheme)
  st.normal_desired_dist = ini:r_string_to_condlist(section, "normal_desired_dist", "4")
end


-- patch: add custom targets to axr_beh.script
-- the original function will initialize all the internals but won't match
-- any known targets, at which point the custom targets take over
function axr_beh.action_beh:set_desired_target()
  local npc   = self.object
  local st    = self.st

  local target = xr_logic.pick_section_from_condlist(db.actor, npc, st.goto_target)

  if st.target == target and st.desired_target then
    st.savedTarget = dup_table(st.desired_target)
  else
    st.savedTarget = {}
  end

  st.lastTarget   = st.target
  st.lastKeepType = st.keepType

  local success = __set_target(self)
  local customTargetFn = CUSTOM_TARGETS[target]

  if success or not (U.isCompanion(npc) and customTargetFn) then
    return success
  end

  st.keepType = xr_logic.pick_section_from_condlist(db.actor, npc, st.keep_distance)
  return customTargetFn(self.object, self.st)
end


-- patch
function axr_beh.action_beh:beh_move()
  local npc = self.object
  local st  = self.st

  if not (U.isCompanion(npc) and CUSTOM_TARGETS[st.target]) then
    return __beh_move(self)
  end

  if not st.setStateFn then
    st.setStateFn = U.throttle(state_mgr.set_state, 100)
  end

  local move = U.getBehMoveState(npc, st)
  local look = U.getBehLookState(npc, st)

  st.setStateFn(npc, move, nil, nil, look, {fast_set = true})
end


-- patch: only override the behaviors below for companions
-- they all do the same thing as beh_move(), but they're called separately
-- to not confuse anything relying on self.st.behavior
function axr_beh.action_beh:beh_wait()
  local npc = self.object
  local st  = self.st

  if not (U.isCompanion(npc) and CUSTOM_TARGETS[st.target]) then
    return __beh_wait(self)
  end

  self:beh_move()
end


-- patch
function axr_beh.action_beh:beh_cover()
  local npc = self.object
  local st  = self.st

  if not (U.isCompanion(npc) and CUSTOM_TARGETS[st.target]) then
    return __beh_cover(self)
  end

  self:beh_move()
end


-- patch:
function axr_beh.action_beh:beh_relax()
  local npc = self.object
  local st  = self.st

  if not (U.isCompanion(npc) and CUSTOM_TARGETS[st.target]) then
    return __beh_wait(self)
  end

  self:beh_move()
end


-- xr_conditions --

function xr_conditions.follow_crouch(actor, npc)
  if not ui_mcm.get("idiots/options/autoSneak") then
    return false
  end
  return IsMoveState("mcCrouch") and U.isFollowing(npc)
end


function xr_conditions.follow_prone(actor, npc)
  if not ui_mcm.get("idiots/options/autoProne") then
    return false
  end
  return IsMoveState("mcCrouch") and IsMoveState("mcAccel") and U.isFollowing(npc)
end


function xr_conditions.follow_sprint(actor, npc)
  if not ui_mcm.get("idiots/options/autoSprint") then
    return false
  end
  return IsMoveState("mcSprint") and U.isFollowing(npc)
end

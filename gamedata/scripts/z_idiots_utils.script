local C     = z_idiots_companions
local TABLE = require "illish.table"


INVALID_LVID = 4294967295
USED_LVIDS   = db.used_level_vertex_ids


-- utils: misc --

function throttle(fn, ms1, ms2)
  local lastRun = 0
  local delay   = 0
  local result  = nil

  return function(...)
    local time = time_global()
    if lastRun + delay <= time then
      delay   = math.random(ms1, ms2 or ms1)
      lastRun = time
      result  = fn(...)
    end

    return result
  end
end


function round(val, prec)
  local e = 10 ^ (prec or 0)
  return math.floor(val * e + 0.5) / e
end


function random(min, max, prec)
  local e    = 10 ^ (prec or 0)
  local emin = math.floor(min * e + 0.5)
  local emax = math.floor(max * e + 0.5)

  return math.random(emin, emax) / e
end


function randomRange(mag, prec)
  return random(-mag, mag, prec)
end


-- utils: vertices/vectors --

function _G.vec(...)
  return vector():set(...)
end


function _G.lvpos(vid)
  return vec(level.vertex_position(vid))
end


function _G.lvid(pos)
  return level.vertex_id(pos) or INVALID_LVID
end


function _G.lvsnap(pos)
  return lvpos(lvid(pos))
end


function _G.vdir(v1, v2)
  return vec(v2):sub(v1):normalize()
end


function vectorOffset(vector, dir, mag)
  return vec(vector):add(
    vec(dir):normalize():mul(mag)
  )
end


function vectorAverage(vectors)
  local total = vec(0, 0, 0)

  for _, point in ipairs(vectors) do
    total:add(point)
  end

  return total:div(#vectors)
end


function vectorRandomize(pos, radius)
  if radius == 0 then
    return pos
  end
  return vec(pos):add(
    randomRotate():mul(random(0, radius or 1, 1))
  )
end


function randomRotate(vector, range)
  return vector_rotate_y(vector or vec(1, 0, 0), randomRange(range or 180))
end


function getRayDistance(pos, dir, range, flags, cap)
  local ray = ray_pick()

  ray:set_position(pos)
  ray:set_direction(dir)
  ray:set_range(range)
  ray:set_flags(flags or 15)
  ray:query()

  local dist = ray:get_distance()

  if cap ~= false and dist == 0 then
    dist = range
  end

  return dist
end


--  --

function isValidLVID(npc, vid)
  return npc and vid
    and vid ~= INVALID_LVID
    and npc:accessible(vid)
end


function isUnclaimedLVID(npc, vid)
  local minDist = 0.4

  if not isValidLVID(npc, vid) then
    return false
  end

  for v, n in pairs(USED_LVIDS) do
    if n ~= npc:id() then
      if v == vid or lvpos(v):distance_to(lvpos(vid)) < minDist then
        return false
      end
    end
  end

  return true
end


function isUnoccupiedLVID(npc, vid,  minSpace)
  minSpace = minSpace or 0.8

  if not isUnclaimedLVID(npc, vid) then
    return false
  end

  local pos = lvpos(vid)
  local occupied = false

  level.iterate_nearest(pos, minSpace + 0.1, function(obj)
    if not obj:is_stalker() or obj:id() == npc:id() or occupied then
      return
    end

    local objPos  = obj:position()
    local usedVid = TABLE.keyof(USED_LVIDS, obj:id())

    if usedVid and usedVid ~= vid then
      objPos = lvpos(usedVid)
    end

    local dist = objPos:distance_to(pos)

    if dist < minSpace then
      occupied = true
    end
  end)

  return not occupied
end


function claimLVID(npc, vid)
  if not (npc and vid) then
    return
  end

  unclaimLVID(npc)
  USED_LVIDS[vid] = npc:id()
end


function unclaimLVID(npc, vid)
  if not npc then
    return
  end

  if vid and USED_LVIDS[vid] == npc:id() then
    USED_LVIDS[vid] = nil
    return
  end

  for v, n in pairs(USED_LVIDS) do
    if n == npc:id() then
      USED_LVIDS[v] = nil
    end
  end
end


function setDestination(npc, vid)
  if not npc then
    return
  end

  clearDestination(npc)
  npc:set_dest_level_vertex_id(vid)
  claimLVID(npc, vid)
end


function clearDestination(npc)
  if not npc then
    return
  end

  npc:set_desired_direction()
  npc:set_desired_position()
  npc:set_path_type(game_object.level_path)
  npc:set_detail_path_type(move.line)
  unclaimLVID(npc)
end


--  --

function bestOpenLVID(npc, pos, validator, minSpace)
  -- BETA disable
  if ui_mcm.get("idiots/beta/legacyPathing") then
    return defaultLVID(npc, npc:position(), pos, validator)
  end
  --

  minSpace = minSpace or 1

  if not (npc and pos and validator) then
    return INVALID_LVID
  end

  local directions  = 8
  local maxDistance = 8

  local baseAngle = 360 / directions
  local baseDir   = vdir(npc:position(), pos)

  for dist = 0, maxDistance, minSpace do
    for index = 0, directions - 1 do
      for _, flip in ipairs({-1, 1}) do
        local dir = vector_rotate_y(baseDir, baseAngle * index * flip)
        local vid = lvid(vectorOffset(pos, dir, dist))

        if validator(npc, vid, minSpace) then
          return vid
        end
      end
    end
  end

  return INVALID_LVID
end


function bestOpenValidLVID(npc, pos)
  return bestOpenLVID(npc, pos, isValidLVID)
end


function bestOpenUnclaimedLVID(npc, pos)
  return bestOpenLVID(npc, pos, isUnclaimedLVID)
end


function bestOpenUnoccupiedLVID(npc, pos, minSpace)
  return bestOpenLVID(npc, pos, isUnoccupiedLVID, minSpace)
end


function bestEnclosedLVID(npc, pos, validator, minSpace)
  -- BETA disable
  if ui_mcm.get("idiots/beta/legacyPathing") then
    return defaultLVID(npc, db.actor:position(), pos, validator)
  end
  --

  minSpace = minSpace or 1

  if not (npc and pos and validator) then
    return INVALID_LVID
  end

  local rayHeight = 1.9

  local basePos  = vec(db.actor:position()):add(0, rayHeight, 0)
  local baseDist = basePos:distance_to_xz(pos)

  local baseDir = vdir(basePos, pos)
  baseDir.y = 0

  local rayDist = getRayDistance(basePos, baseDir, baseDist)
  local dist = rayDist

  while dist > 0 do
    local vid = lvid(vectorOffset(basePos, baseDir, dist))

    if validator(npc, vid, minSpace) then
      return vid
    end

    dist = dist - minSpace
  end

  return INVALID_LVID
end


function bestEnclosedValidLVID(npc, pos)
  return bestEnclosedLVID(npc, pos, isValidLVID)
end


function bestEnclosedUnclaimedLVID(npc, pos)
  return bestEnclosedLVID(npc, pos, isUnclaimedLVID)
end


function bestEnclosedUnoccupiedLVID(npc, pos, minSpace)
  return bestEnclosedLVID(npc, pos, isUnoccupiedLVID, minSpace)
end


function defaultLVID(npc, basePos, pos, validator, minDist)
  minDist = minDist or 1

  if not (npc and basePos and pos and validator) then
    return INVALID_LVID
  end

  local baseDist = basePos:distance_to_xz(pos)
  local dist     = baseDist

  while dist > 0 do
    local vid = level.vertex_in_direction(lvid(basePos), vdir(basePos, pos), dist)
    if validator(npc, vid, minDist) then
      return vid
    end

    dist = dist - minDist
  end

  return INVALID_LVID
end


function defaultOpenValidLVID(npc, pos)
  return defaultLVID(npc, npc:position(), pos, isValidLVID)
end


function defaultOpenUnclaimedLVID(npc, pos)
  return defaultLVID(npc, npc:position(), pos, isUnclaimedLVID)
end


function defaultOpenUnoccupiedLVID(npc, pos, minSpace)
  return defaultLVID(npc, npc:position(), pos, isUnoccupiedLVID, minSpace)
end


function defaultEnclosedValidLVID(npc, pos)
  return defaultLVID(npc, db.actor:position(), pos, isValidLVID)
end


function defaultEnclosedUnclaimedLVID(npc, pos)
  return defaultLVID(npc, db.actor:position(), pos, isUnclaimedLVID)
end


function defaultEnclosedUnoccupiedLVID(npc, pos, minSpace)
  return defaultLVID(npc, db.actor:position(), pos, isUnoccupiedLVID, minSpace)
end


-- utils: NPCs/companions --

function getNPC(id)
  local  npc = db.storage[id] and db.storage[id].object
  return npc or level.object_by_id(id)
end


function isCompanion(npc)
  if type(npc) == "number" then
    npc = getNPC(npc)
  end

  return npc
    and not axr_task_manager.hostages_by_id[npc:id()]
    and npc:has_info("npcx_is_companion")
    and npc:alive()
    and true or false
end


function isFollowing(npc)
  if type(npc) == "number" then
    npc = getNPC(npc)
  end

  return npc
    and isCompanion(npc)
    and (C.getState(npc, "movement", "follow"))
end


function getCompanion(id)
  local npc = getNPC(id)
  return isCompanion(npc) and npc or nil
end


function getCompanions()
  local companions = {}

  for sid, squad in pairs(axr_companions.companion_squads) do
    if
      squad
      and squad.commander_id
      and not axr_task_manager.hostages_by_id[squad:commander_id()]
    then
      for member in squad:squad_members() do
        local companion = getCompanion(member.id)
        if companion then
          companions[#companions + 1] = companion
        end
      end
    end
  end

  return companions
end


function getCompanionsInTheWay()
  local pathWidth = 1.2
  local maxDist   = 12

  local companions = {}

  for i, npc in ipairs(getCompanions()) do
    local dist     = distance_between(db.actor, npc)
    local minAngle = math.abs(math.deg(math.tan(pathWidth / 2 / dist)))
    local dir      = vdir(db.actor:position(), npc:position())
    local angle1   = math.deg(db.actor:direction():getH())
    local angle2   = math.deg(dir:getH())
    local angle    = math.abs(angle2 - angle1)

    if dist <= maxDist and angle < minAngle then
      companions[#companions + 1] = npc
    end
  end

  table.sort(companions, function(a, b)
    return distance_between(a, db.actor) > distance_between(b, db.actor)
  end)

  return companions
end


function getFollowers()
  local following = {}

  for _, npc in ipairs(getCompanions()) do
    if isFollowing(npc) then
      following[#following + 1] = npc
    end
  end

  return following
end


function getTargetCompanion(maxDist)
  local npc = level.get_target_obj()

  if not isCompanion(npc) then
    return
  end

  if maxDist and distance_between(db.actor, npc) > maxDist then
    return
  end

  return npc
end


function indexOfCompanion(npc)
  if type(npc) == "number" then
    npc = getNPC(npc)
  end
  if not npc then
    return
  end
  for i, companion in ipairs(getCompanions()) do
    if companion:id() == npc:id() then
      return i
    end
  end
end


function indexOfFollower(npc)
  if type(npc) == "number" then
    npc = getNPC(npc)
  end
  if not npc then
    return
  end
  for i, follower in ipairs(getFollowers()) do
    if follower:id() == npc:id() then
      return i
    end
  end
end


function getAvgPosition(npcs)
  local pos = {}
  local dir = {}

  for i, npc in ipairs(npcs) do
    pos[i] = npc:position()
    dir[i] = npc:direction()
  end

  return vectorAverage(pos), vectorAverage(dir)
end


function isReloading(npc)
  local item = npc:active_item()
  return IsWeapon(item) and item:get_ammo_in_magazine() <= 0
end


function setInfoPortion(npc, info, enabled)
  if type(npc) == "number" then
    npc = getCompanion(npc)
  end

  if not npc then
    return
  end

  if not enabled then
    npc:disable_info_portion(info)
    return
  end

  npc:give_info_portion(info)
end


--  --

function evaluateCover(npc, enemyPos)
  if not npc then
    return
  end

  local pos = npc:position()

  if not enemyPos then
    enemyPos = lvsnap(vectorOffset(pos, npc:direction(), 8))
  end

  local positions = {
    low  = {vec(pos), vec(enemyPos), 0.75},
    mid  = {vec(pos), vec(enemyPos), 1.10},
    high = {vec(pos), vec(enemyPos), 1.60},
  }

  enemyPos.y = enemyPos.y + positions.high[3]
  local covers = {}

  for k, v in pairs(positions) do
    v[1].y = v[1].y + v[3]
    v[2].y = v[2].y + v[3]

    local dist = v[1]:distance_to(v[2])
    local dir  = vdir(v[1], v[2])
    local ray  = ray_pick()

    ray:set_flags(2)
    ray:set_position(v[1])
    ray:set_direction(dir)
    ray:set_range(dist)
    ray:query()

    local raydist = ray:get_distance()

    covers[k] = raydist > 0
      and math.floor(dist - raydist) > 0
  end

  return covers
end


function evaluateSurroundings(pos, ops)
  -- BETA disable
  if ui_mcm.get("idiots/beta/noSpatial") then
    return {type = "enclosed", average = 0}
  end
  --

  ops = TABLE.merge({
    height     = 1.9,
    flags      = 15,
    maxDist    = 16,
    rayCount   = 16,
    openRange  = 9.8,
    closeRange = 3.2,
  }, ops)

  local rayPos = vec(pos):add(0, ops.height, 0)
  local angle  = 360 / ops.rayCount
  local dir    = vec(1, 0, 0)

  local distances = {}

  for index = 1, ops.rayCount do
    local rayDir = vector_rotate_y(vec(dir), -angle * (index - 1))
    local dist   = round(getRayDistance(rayPos, rayDir, ops.maxDist, ops.flags), 1)

    distances[index] = dist
  end

  table.sort(distances)
  local cullCount = round(ops.rayCount / 10)

  for i = 1, cullCount do
    table.remove(distances, 1)
    table.remove(distances, #distances)
  end

  local avg = TABLE.average(distances)

  local type = avg >= ops.openRange
    and "open"
    or  avg >= ops.closeRange
    and "enclosed"
    or  "cramped"

  return {type = type, average = avg}
end


function findSafeCover(npc, ops)
  ops = TABLE.merge({
    position = npc:position(),
    radius   = 32,
    minDist  = 1,
    minSpace = 1,
  }, ops)

  local cover = npc:safe_cover(ops.position, ops.radius, ops.minDist)

  if cover then
    return bestOpenUnoccupiedLVID(npc, cover:position(), ops.minSpace)
  end

  return INVALID_LVID
end


function findBestCover(npc, enemyPos, minSpace)
  local cover = npc:find_best_cover(enemyPos or db.actor:position())

  if cover then
    return bestOpenUnoccupiedLVID(npc, cover:position(), minSpace or 1)
  end

  return INVALID_LVID
end


function findCover(npc, ops)
  ops = TABLE.merge({
    position  = npc:position(),
    enemyPos  = db.actor:position(),
    maxRadius = 32,
    radius    = 8,
    distance  = 0,
    minSpace  = 1,
  }, ops)

  local dir = vdir(ops.position, ops.enemyPos):invert()
  local pos = vectorOffset(ops.position, dir, ops.distance)

  local radius = ops.radius

  while true do
    local cover = npc:best_cover(pos, ops.enemyPos, radius, 1, 128)

    if cover then
      return bestOpenUnoccupiedLVID(npc, cover:position(), ops.minSpace)
    end

    if radius >= ops.maxRadius then
      break
    end

    radius = math.min(radius + math.min(radius, 4), ops.maxRadius)
  end

  return INVALID_LVID
end


function moveToPoint(npc, pos, radius, minSpace)
  if type(npc) == "number" then
    npc = getCompanion(npc)
  end

  minSpace = minSpace or 2
  radius   = radius   or 2

  local randPos = vectorRandomize(pos, radius)
  local vid     = bestEnclosedUnoccupiedLVID(npc, randPos, minSpace)

  if not isValidLVID(npc, vid) then
    return
  end

  local st = db.storage[npc:id()]

  if st.enemy then
    st.combat.movePoint = vid
  else
    st.beh.movePoint  = vid
    st.beh.rally_lvid = vid
  end

  claimLVID(npc, vid)
end


function moveOutOfTheWay(npc, ops)
  ops = TABLE.merge({
    moveState  = "sprint",
    range      = 180,
    attempts   = 8,
    minDist    = 1.2,
    strafeDist = 2.4,
    backDist   = 8,
  }, ops)

  local baseDir = vdir(db.actor:position(), npc:position())
  local flip    = random(0, 1) * 2 - 1
  local angles  = {}

  local bestVid
  local bestDist = 0

  for i = 0, ops.attempts do
    angles[#angles + 1] = (i * (ops.range / ops.attempts) - ops.range / 2) * flip
  end

  table.sort(angles, function(a, b)
    return math.abs(a) > math.abs(b)
  end)

  for i, angle in ipairs(angles) do
    local idealDist = math.abs(angle) > 30
      and ops.strafeDist
      or  ops.backDist

    local dir    = vector_rotate_y(baseDir, angle)
    local rawpos = vectorOffset(npc:position(), dir, idealDist)
    local vid    = defaultOpenValidLVID(npc, rawpos)
    local dist   = npc:position():distance_to(lvpos(vid))

    if isValidLVID(npc, vid) then
      if dist > bestDist then
        bestVid  = vid
        bestDist = dist
      end

      if dist >= ops.minDist then
        break
      end
    end
  end

  if not bestVid then
    return
  end

  local st = db.storage[npc:id()]

  if st.enemy then
    st.combat.movePoint = bestVid
  else
    st.beh.moveState  = ops.moveState
    st.beh.movePoint  = bestVid
    st.beh.rally_lvid = bestVid
  end

  claimLVID(npc, bestVid)
end
